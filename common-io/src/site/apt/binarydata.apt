Description

 Le sous package <storage> du <common-io> offre un méchanisme de trasfert des fichiers binaires d'un support à un autre en arrière plan.
 Cela est surtout très pratique pour transférer les images d'une base de données (couteux) vers un stockage moins couteux
 comme <google cloud> par exemple.

Cas d'utilisation

 Nous souhaitons, par exemple, dans une application stocker des fichiers binaires dans la même transaction que ses méta-données.
 Pour cela il suffit de créer une ou plusieurs tables en base de données afin de stocker les binaires et les méta-données.
 Cependant stocker les données binaires en base de données est couteux, et les stocker dans un <file system> ne nous permet pas d'utiliser les avantages des transactions.
 L'idéal, serait de stocker les données binaires en base de données avec les métadonnés et une fois la transaction commitée, de déplacer les données
 binaires vers un autre support. C'est le principe mis en place dans le sous package <storage> de <common-io>

Comment intégrer le méchanisme du sous package <storage> au sein de son application ?

 * Créer un service implémentant <BinaryDataService>

  Lors de l'appel de ce service, si vous souhaitez savoir dans quel domaine les méthodes de ce service sont invoquées, vous pouvez utiliser la classe <DomainContext>.

+------------------------------------------+
import com.calinfo.api.common.io.storage.service.BinaryDataService;
import org.springframework.stereotype.Service;

@Service
public class MyBinaryDataService implements BinaryDataService {

    ...
}
+------------------------------------------+

 * Multi tenant

 Si votre application est une applciation multi tenant, c'est à dire avec plusieurs domaines, il vous faudra implémenter le service <BinaryDataDomainService>.

+------------------------------------------+
import com.calinfo.api.common.io.storage.service.BinaryDataDomainService;
import org.springframework.stereotype.Service;

@Service
public class MyBinaryDataDomainService implements BinaryDataDomainService {

    ...
}

+------------------------------------------+

 * Connecteur

 Ensuite le sous package <storage> de <common-io> a besoins de savoir comment lire et écrire des fichiers sur un autre support.
 Dans ce cas, il vous faudra implémenter le composant <BinaryDataConnector>.

+------------------------------------------+
import com.calinfo.api.common.io.storage.connector.BinaryDataConnector;
import org.springframework.stereotype.Component;

@Component
public class MyBinaryDataConnector implements BinaryDataConnector {

    ...
}

+------------------------------------------+

 NB : La classe <BinaryDataConnector> possède deux autres méthodes <createSpace> et <deleteSpace> permettant de crééer ou de supprimer un espace de stockage.
 On peu voir un espace de stockage un peu comme un schéma de base de données.

 Il existe un connecteur (une implémentation de <BinaryDataConnector>) déjà implémenté pour transférer les fichiers sur un <bucket> google.
 Cela vous évite d'écrire une classe comme <MyBinaryDataConnector> de l'exemple ci-dessus. Pour utiliser ce connecteur, il vous suffit d'ajouter dans le fichier
 de configuration (ex : application.yml) les éléments suivants :

+------------------------------------------+

common-io:
  storage:
    connector:
      provider: google
      configuration: # Voir les propriétés de la classe GoogleConfigProperties

+------------------------------------------+

 Voici un exemple de configuration

+------------------------------------------+

common-io:
  storage:
    connector:
      provider: google
      configuration:
        projectId: "services-dev-jeb"
        credentials: >
          {
            "type": "service_account",
            "project_id": "services-dev-jeb",
            "private_key_id": "31f5f121afeec4dc7f38230b50e5234dab366639",
            "private_key": "-----BEGIN PRIVATE KEY-----\nMIIEvgIBADANBgkqhkiG9w0BAQEFBBSCBKgwggSkAgEAAoIBAQCj7XLnMHAGf3/j\nURs5f+nm0dWyKeFnrS8H/zRMeOLmiZn7/RH2X7KdPo3dPYwSNE7ZEGup6AWnl7MN\nmsSIL4kurp3E24ucF6pRP0XRl8HLGrORFIb4NBw2vAXD1A37uVUqxtRaYamzA2x5\nPbA+YjtpFDS2AKP0Q9/9r6RyKu6vOsit/eePYRKT2YTNhT0Xu2xnUzZ0I4n2BLBQ\nMOpnXyTrp8bcqPIthyUzYR0bnRlxHF2YPADn1z4TtflxKzVwXstBT/WVMupyjcBN\n7Bwz29WfqIlky2e+4vrxYrVvsNdW75rK7DTCTyna/GaFKNcwRrVQ6sZnhxYXsCs+\n+w6U1WxXAgMBAAECggEABFF83GcarqpIUS0ayzVnkP7oGcz7NPnUhcVDuG5IhjAw\nWUKZRGT1Q3LijPh2zyf1UOyI0GRL541RDzFm97JOl9TwU+P3jNPUe3smyvti3/VC\n07ZJuH/YEUh7kmU10IUQDW9tcYJc1H6N4WfAeGHzgmtFaw+yHWq/LfXJjDarUPxd\npTKhrupRy2flyN6wEPExRGUz+xi8T2UowU/VrGqvzZFx000aZ4YVclRWUO+N5A0s\nRdbS3Hx9G4Tq2ZUHuSmP66Eak4e3NrZciySixJ1upUwHrBdJ+HvBKa8ds3i0NnrO\niQd6EQfti/93owKeHoYWIt4bOQCc+bwin1XKH3clGQKBgQDUAQLleHaymTNKpxOp\nmJgmNYBdAggVX8GlnNo9J3Sr/aNRsXhF2yTBxSog6VyXY4Q1+VbtBILJqpSi2DvR\n5tLUnx/XrOJBQfvcW9RXtNB4Be2Kg1pfAiwluJfD7tZV4Nkct12NUjCi1FZMkdKv\nnFiZcE5iSErQ1JaPWwu9F99v+wKBgQDF8lCQXC84o91cNHtPC3W7Gk3TfbyOups6\nCfRNwrDB+WtvUURf+BI2zLP/dd33yOMzkPaOUuSKRUjPwVlzWpVbRKOT3jBEa8Fj\nRGJuPjx44eLuQUfNZOhpcJctiMz+xooAshdV6bZOAvX5YnKQOTbGjtQh0snByhWt\n7q1e0SVaVQKBgCGkh3EizLNK3HjcSqJ/NKXbl6Mqz12U9IXzfi52NG2WsnQkVZHA\nVPTq9OSEI81iXXizOLgkHx0hlLTC27tTheF33vW62azBa9ZsPCYu62YgirGQZqbt\nEVRrFqphHGJEbC/CaXYjtNQiHg/IlEaJ6QVwbP/ruPOqyLm3GQXI5AxBAoGBAKrE\n6MIR9V8c50yzrim8Tj4zbC7ny7Mqw93nVo97RfiiUBBCAQX2Quhp42OhcPRip7gF\n+N9CHg43xaAOQzhkTnPlnGVmCygL+lPEXFKVeKAk6Bz5zpMg2eyVCKds3MVzzPza\np40jynY00bXrO8C2y02zTMk9S3fW+qsKPSGOt3XdAoGBAL2Bbu/Ycj0cTUu/pO8f\nAvTa2eI0sBNWeXWMTB5NY42LW02xjb/gd64q/QuMKb0AR1AIlCkB/l0HXSmh35PP\no1OL5EfwRc/BcWD8FrfmTYBuhU3BOb8qlEm/nIuINuXnYzXpln4EmRk+IXjBLdE7\nOklz+wPk1O+SeXha9ntt4WrG\n-----END PRIVATE KEY-----\n",
            "client_email": "calinfo-default-dev-bucket@services-dev-jeb.iam.gserviceaccount.com",
            "client_id": "100439927192752185861",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/calinfo-default-dev-bucket%40services-dev-jeb.iam.gserviceaccount.com"
          }
        buckatName: "test_bucket_calinfo"

+------------------------------------------+

 * Enfin la configuration nécessaire pour mettre en oeuvre de méchanisme du sous package <storage> de <common-io>

 Ajouter les lignes ci-dessous dans le fichier de propriété (ex : application.yml)

+------------------------------------------+
common-io:
  storage:
    scheduler:
      enabled: true     # true pour activer le transfert de donnée binaire
      delay: 60000      # Délai en mili seconde entre chaque tentative de transfert


+------------------------------------------+

 * Multi-threading

 ATTENTION : chaque transfert de fichier est lancé dans un thread à part. Il est fortement recommandé de maitriser le nombre de Thread
 lancé simultanément. pour cela vous devrez créer un bean nommé <"binaryDataASyncTransfert"> de type <org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor>

 Ci-dessous un exemple d'implémentation

+------------------------------------------+
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.TaskExecutor;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor;

@Configuration
@EnableAsync
public class ThreadConfig {

    private static final int HEURE = 60 * 60;

    @Bean(name = "binaryDataASyncTransfert")
    public TaskExecutor saveEsActionThreadPoolExecutor() {
        return createExecutor(1, 12 * HEURE, "binaryDataASyncTransfert_");
    }

    private TaskExecutor createExecutor(int corePoolSize, int keepAliveSeconds, String threadNamePrefix) {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(corePoolSize);
        executor.setKeepAliveSeconds(keepAliveSeconds);
        executor.setThreadNamePrefix(threadNamePrefix);
        executor.initialize();
        return new DelegatingSecurityContextAsyncTaskExecutor(executor);
    }
}


+------------------------------------------+