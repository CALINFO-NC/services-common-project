Description

 La gestion <multi-tenant> implémentée par le <common> est un mécanisme permettant, pour une seule instance d'une application, d'avoir plusieurs schémas d'une même structure de base de données.
 Dans le reste du <common>, nous avons appelé <domain> une représentation de ce schéma. Ajouter à cela, le <common> sait gérer une base de données commune pour tous les domaines.
 Exemple de cas d'utilisation : Avoir une table commune de devises pour chaque <domain>. Inutile de dupliquer cette table dans chacun des <domain>. Il est préférable que celle-ci soit partagée.

 * Le <domain> peut être défini lors de l'authentification de l'utilsiateur :
 En effet, lors de l'authentification de l'utilisateur, le <token> peut véhiculer le <domain> auquel l'utilisateur s'authentifie. Ce <domain> peut être
 ensuite utilisé par le développeur en appelant la méthode <getDomain()> d'une instance de <AbstractCommonPrincipal> (Voir la sécurité pour plus de détails).

 * Le <domain> peut être défini par le développeur lors de l'appel d'une requête HTTP :
 Pour cela, le développeur doit indiquer lors de l'appel d'une requête HTTP, quel est le <domain> souhaité. Pour se faire, le développeur
 doit injecter une instance de <com.calinfo.api.common.tenant.RequestDomainName> et utiliser la méthode <setValue(...)> pour préciser le <domain> souhaité.

+------------------------------------------+
Exemple d'implémentation :

@Component
public class MyFilter extends OncePerRequestFilter {

    @Autowired
    private RequestDomainName requestDomainName;

    @Override
    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {

        String domainName = httpServletRequest.getHeader("X-Domain");

        requestDomainName.setValue(domainName);

        filterChain.doFilter(httpServletRequest, httpServletResponse);
    }
}
+------------------------------------------+

 Dans l'exemple ci-dessus, le <domain> est passé par la requête HTTP via le <Header "X-Domain">.

 []

Comment le <common> sait-il quels sont les <repository> et les <entity> utilisés pour un <domain> et ceux utilisés pour la base de données commune (ou générique) ?

 Le développeur doit indiquer ces informations au <common>.

  * Pour indiquer les <entity> pour le <domain> le développeur doit, dans le fichier <yaml>, définir la configuration <common.configuration.tenant.domainScanEntities>

  * Pour indiquer les <entity> pour la base de données générique, le développeur doit, dans le fichier <yaml>, définir la configuration <common.configuration.tenant.genericScanEntities>.

  * Pour indiquer les <jpaRepository> pour le <domain>, le développeur doit écrire la classe ci-dessous en indiquant dans <basePackages> la liste des packages concernés par le <domain>.

+------------------------------------------+
import com.calinfo.api.common.tenant.TenantDatasourceConfiguration;
import com.calinfo.api.common.tenant.TenantProperties;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@ConditionalOnProperty(TenantProperties.CONDITIONNAL_PROPERTY)
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
        entityManagerFactoryRef = TenantDatasourceConfiguration.ENTITY_MANAGER_FACTORY_REF,
        transactionManagerRef = TenantDatasourceConfiguration.TRANSACTION_MANAGER_REF,
        basePackages = {...}
)
public class DomainDatasourceConfiguration extends TenantDatasourceConfiguration {
}
+------------------------------------------+

  * Pour indiquer les <jpaRepository> pour la base de données générique, le développeur doit écrire la classe ci-dessous en indiquant dans <basePackages> la liste des packages concernés par la base de données générique.

+------------------------------------------+
import com.calinfo.api.common.tenant.DefaultDatasourceConfiguration;
import com.calinfo.api.common.tenant.TenantProperties;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@ConditionalOnProperty(TenantProperties.CONDITIONNAL_PROPERTY)
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
        entityManagerFactoryRef = DefaultDatasourceConfiguration.ENTITY_MANAGER_FACTORY_REF,
        transactionManagerRef = DefaultDatasourceConfiguration.TRANSACTION_MANAGER_REF,
        basePackages = {...}
)
public class GenericDatasourceConfiguration extends DefaultDatasourceConfiguration {
}
+------------------------------------------+

Comment le <common> sait-il s'il faut utiliser le <domain> défini par le développeur lors de la requête HTTP ou le <domain> défini lors de l'authentification ?

 Le <common> injecte une instance de <com.calinfo.api.common.tenant.DomainNameResolver> et appelle la méthode <getDomain()> de cette instance pour définir le <domain> à utiliser.
 Le développeur doit donc s'assurer qu'une telle instance peut être injectée. Le <common> propose une implémentation partielle de l'interface <com.calinfo.api.common.tenant.DomainNameResolver> via
 la classe abstraite <com.calinfo.api.common.tenant.AbstractDefaultDomainNameResolver>.
 Ci-dessous un exemple de classe pouvant être écrite par le développeur :

+------------------------------------------+
import com.calinfo.api.common.tenant.AbstractDefaultDomainNameResolver;
import com.calinfo.api.common.tenant.TenantProperties;
import org.apache.commons.lang3.StringUtils;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

/**
 * Created by dalexis on 31/05/2018.
 */
@ConditionalOnProperty(TenantProperties.CONDITIONNAL_PROPERTY)
@Component
public class DomainNameResolver extends AbstractDefaultDomainNameResolver {

    @Override
    protected String choiceDomain(String requestDomain, String securityPrincipalDomain) {
        return StringUtils.isBlank(requestDomain) ? securityPrincipalDomain : requestDomain;
    }
}
+------------------------------------------+

Comment créer un <domain> par programme ?

 La création d'un <domain> consiste à créer un schéma de base de donnée, et éventuellement jouer les scripts <liquibase>.

 Le code ci-dessous donne un exemple de comment y parvenir :

+------------------------------------------+
import com.calinfo.api.common.tenant.TenantDatasourceConfiguration;
import com.calinfo.api.common.tenant.TenantProperties;
import com.calinfo.api.common.utils.DatabaseUtils;
import com.calinfo.api.common.utils.LiquibaseUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

/**
 * Created by dalexis on 30/12/2017.
 */
@Component
public class MyExample {


    @Autowired
    @Qualifier(TenantDatasourceConfiguration.TENANT_DATASOURCE) // Ne pas utiliser de qualifier pour la base de données générique
    private DataSource tenantDataSource;

    @Autowired
    private TenantProperties tenantProperties;

    public void call(String domain) {

        String schemaName = TenantDatasourceConfiguration.getSchemaName(tenantProperties.getPrefix(), domain);
        DatabaseUtils.createSchema(tenantDataSource, schemaName);
        LiquibaseUtils.updateSchema(tenantDataSource, tenantProperties.getLiquibase().getChangeLog(), schemaName);

    }
}
+------------------------------------------+

Configuration

 La configuration du <tenant> se fait dans la sous configuration <common.configuration.tenant> du fichier <yaml> .
 Toutes les propriétés de cette sous configuration sont décrites dans la JavaDoc de la classe <com.calinfo.api.common.tenant.TenantProperties>


