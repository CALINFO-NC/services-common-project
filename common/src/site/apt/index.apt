Description

 La gestion multi-tenant implémenté par le common est un mécanisme permettant, pour une seule instance d'une application, d'avoir plusieurs schéma d'une même structure de base de données.
 Dans le reste du common, nous avons appelé <domain> un représentation de ce schéma. Ajouter à cela, le common sait gérer une base de données commune pour tous les domaines.
 Exemple de cas d'utilisation : Avoir une table commune de devise pour chaque <domain>. Inutile de dupliquer cette table dans chacun des <domain>. Il est préférable que celle ci soit partagée.

 Le common peut définir deux valeurs de <domain>.

 * Le <domain> définie lors de l'authentification de l'utilsiateur :
 En effet lors de l'authentification de l'utilisateur, le token peut véhiculer le <domain> auquel l'utilisateur s'authentifie. Ce domaine peut être
 ensuite utilisé par le développeur en appelant la méthode <getDomain()> d'une instance de <AbstractCommonPrincipal> (Voir la sécurité pour plus de détail).

 * Le <domain> définie par le développeur lors de l'appel d'une URL :
 Pour cela le développeur doit indiquer, lors de l'appel d'une requête HTTP, quel est le domain pointé par cette même requête. Pour ce faire, le développeur
 doit injecter une instance de <com.calinfo.api.common.tenant.RequestDomainName> et utiliser la méthode <setValue(...)> pour préciser le <domain> pointé.

+------------------------------------------+
Exemple d'implémentation :

@Component
public class MyFilter extends OncePerRequestFilter {

    @Autowired
    private RequestDomainName requestDomainName;

    @Override
    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {

        String domainName = httpServletRequest.getHeader("X-Domain");

        requestDomainName.setValue(domainName);

        filterChain.doFilter(httpServletRequest, httpServletResponse);
    }
}
+------------------------------------------+

 Dans l'example ci-dessus, le <domain> est passé par la requête HTTP via le <Header "X-Domain">.

 []

Comment le common sait il quel sont les <repository> et les <entity> utilisés pour un <domain> et ceux utilisé pour la base de données commune (ou générique) ?

 Le développeur doit indiquer ces informations au common.

  * Pour indiquer les <entity> pour le <domain> le développeur doit, dans le fichier <yaml>, définir la configuration <common.configuration.tenant.domainScanEntities>

  * Pour indiquer les <entity> pour la base de données générique, le développeur doit, dans le fichier <yaml>, définir la configuration <common.configuration.tenant.genericScanEntities>.

  * Pour indiquer les <jpaRepository> pour le <domain>, le développeur doit écrire la classe ci-dessous en indiquant dans <basePackages> la liste des packages concerné par le <domain>.

+------------------------------------------+
import com.calinfo.api.common.tenant.TenantDatasourceConfiguration;
import com.calinfo.api.common.tenant.TenantProperties;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@ConditionalOnProperty(TenantProperties.CONDITIONNAL_PROPERTY)
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
        entityManagerFactoryRef = TenantDatasourceConfiguration.ENTITY_MANAGER_FACTORY_REF,
        transactionManagerRef = TenantDatasourceConfiguration.TRANSACTION_MANAGER_REF,
        basePackages = {...}
)
public class DomainDatasourceConfiguration extends TenantDatasourceConfiguration {
}
+------------------------------------------+

  * Pour indiquer les <jpaRepository> pour la base de données générique, le développeur doit écrire la classe ci-dessous en indiquant dans <basePackages> la liste des packages concernés par la base de données générique.

+------------------------------------------+
import com.calinfo.api.common.tenant.DefaultDatasourceConfiguration;
import com.calinfo.api.common.tenant.TenantProperties;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@ConditionalOnProperty(TenantProperties.CONDITIONNAL_PROPERTY)
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
        entityManagerFactoryRef = DefaultDatasourceConfiguration.ENTITY_MANAGER_FACTORY_REF,
        transactionManagerRef = DefaultDatasourceConfiguration.TRANSACTION_MANAGER_REF,
        basePackages = {...}
)
public class GenericDatasourceConfiguration extends DefaultDatasourceConfiguration {
}
+------------------------------------------+

Comment le common sait il s'im faut utiliser le <domain> définie par le développeur lors de la requête HTTP ou le <domain> définie lors de l'authentification ?

 Le common inject une instance de <com.calinfo.api.common.tenant.DomainNameResolver> et appel la méthode <getDomain()> de cette instance pour définir le domain à utiliser.
 Le développeur doit donc s'assurer qu'une tel instance peut être injecter. Le common propose une implémentation partielle de l'interface <com.calinfo.api.common.tenant.DomainNameResolver> via la classe abstraite <com.calinfo.api.common.tenant.AbstractDefaultDomainNameResolver>.
 Ci-dessous un exemple de classe pouvant être écrit par le développeur :

+------------------------------------------+
import com.calinfo.api.common.tenant.AbstractDefaultDomainNameResolver;
import com.calinfo.api.common.tenant.TenantProperties;
import org.apache.commons.lang3.StringUtils;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Profile;
import org.springframework.stereotype.Component;

/**
 * Created by dalexis on 31/05/2018.
 */
@ConditionalOnProperty(TenantProperties.CONDITIONNAL_PROPERTY)
@Component
public class DomainNameResolver extends AbstractDefaultDomainNameResolver {

    @Override
    protected String choiceDomain(String requestDomain, String securityPrincipalDomain) {
        return StringUtils.isBlank(requestDomain) ? securityPrincipalDomain : requestDomain;
    }
}
+------------------------------------------+

Comment créer un domain par programme ?

 La création d'un domain consiste à créer un schéma de base de donnée, et éventuellement jouer les scripts liquibase.

 Le code ci-dessous donne un exemple de comment y parvenir

+------------------------------------------+
import com.calinfo.api.common.tenant.TenantDatasourceConfiguration;
import com.calinfo.api.common.tenant.TenantProperties;
import com.calinfo.api.common.utils.DatabaseUtils;
import com.calinfo.api.common.utils.LiquibaseUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

import javax.sql.DataSource;

/**
 * Created by dalexis on 30/12/2017.
 */
@Component
public class MyExample {


    @Autowired
    @Qualifier(TenantDatasourceConfiguration.TENANT_DATASOURCE) // Ne pas utiliser de qualifier pour la base de données générique
    private DataSource tenantDataSource;

    @Autowired
    private TenantProperties tenantProperties;

    public void call(String domain) {

        String schemaName = TenantDatasourceConfiguration.getSchemaName(tenantProperties.getPrefix(), domain);
        DatabaseUtils.createSchema(tenantDataSource, schemaName);
        LiquibaseUtils.updateSchema(tenantDataSource, tenantProperties.getLiquibase().getChangeLog(), schemaName);

    }
}
+------------------------------------------+

Configuration

 La configuration du <tenant> se fait dans le fichier <yaml> dans la sous config <common.configuration.tenant>.
 Toutes les propriétés de cette sous config sont décritent dans la JavaDoc de la classe <com.calinfo.api.common.tenant.TenantProperties>


